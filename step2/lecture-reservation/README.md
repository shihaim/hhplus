# [Step2 - 클린 아키텍처]
## 특강 신청 API
| 메서드  | 요청 URL                    |
|------|---------------------------|
| POST | /api/v1/lectures/{userId} |

### 비즈니스 로직 흐름
1. 특강 신청 목록 확인
   - 해당 특강 목록 조회
      1. 4월 20일 토요일 1시 이전인 경우에는 실패하는 케이스
      2. 특강의 개수가 0 미만이면 Error Throwing
      3. 특강 예약 목록 조회(Lazy vs Eager, fetch join)
         - 같은 유저가 중복하여 신청한 경우 Error Throwing

### 동시성
#### 1. Task Queue
Queue를 통하여 순차적으로 실행할 수 있도록 제어합니다.
#### 2. ConcurrentHashMap
특강 ID에 Lock을 걸어 ConcurrentHashMap에 저장하는 방식으로 동시성을 제어합니다.
#### 3. 낙관적 락
Hibernate의 ```@Version```을 통해 동시성을 제어합니다.
#### 4. 비관적 락
JPA에서 제공해주는 ```@Lock```을 이용하여 ```select for update```방식으로 동시성을 제어합니다.
#### 결론
저는 4번을 선택했습니다.   
그 이유는 프레임워크의 힘을 빌리고 엔티티 레벨에서 풀어 내는 것이 좀 더 쉽다고 느껴져서 입니다.

## 특강 신청 완료 여부 조회 API
| 메서드  | 요청 URL                        |
|------|-------------------------------|
| GET | GET /api/v1/lectures/{userId} |



## ERD
![erd](https://github.com/shihaim/hhplus/step2/특강_ERD.png)

---
### 추가 요구사항
- 날짜별 특강이 존재
- 날짜별 특강 목록 조회

---
### 질문리스트
1. 신청의 경우 사실상 로그인한 유저가 특강 목록에서 신청하게 되는데,
   PathVariable 방식을 채택하지 않고, 세션이나 토큰 방식으로 검증하여
   로그인한 유저ID에 대해 Request 파라미터로 넘긴다고 생각하고
   코드를 작성하는 것이 맞는지 궁금합니다.
2. 특강 목록 Entity와 특강 신청 목록 Entity를 1:N으로 구상하였습니다.
   그런데 궁금한 것이 특강 목록 Entity를 통해서 구현하려고하니깐, 더미데이터가 생기지 않을까?
   라는 생각이 들었습니다.   
   그렇게 생각한 이유는 해당 시간에 열리는 날짜에 특강을 30개를 둔다고 생각하면, 
   다 소진이 된 후에는 이용 가치가 없어지는 데이터가 아닌가? 라는 생각이 들었고, 그것이 아니라면
   같은 특강이더라도 강의 개수와 특강 날짜만 Update를 해주면 더이상 더미 데이터가 아니게 되는가?
   도 생각 했습니다.   
   이부분에 대해서 어떻게 생각하시는지 궁금합니다.